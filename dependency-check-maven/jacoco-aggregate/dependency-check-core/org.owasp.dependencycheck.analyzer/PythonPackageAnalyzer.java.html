<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PythonPackageAnalyzer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Dependency-Check Maven Plugin</a> &gt; <a href="../index.html" class="el_bundle">dependency-check-core</a> &gt; <a href="index.source.html" class="el_package">org.owasp.dependencycheck.analyzer</a> &gt; <span class="el_source">PythonPackageAnalyzer.java</span></div><h1>PythonPackageAnalyzer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of dependency-check-core.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2015 Institute for Defense Analyses. All Rights Reserved.
 */
package org.owasp.dependencycheck.analyzer;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.filefilter.NameFileFilter;
import org.apache.commons.io.filefilter.SuffixFileFilter;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.analyzer.exception.AnalysisException;
import org.owasp.dependencycheck.dependency.Confidence;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.EvidenceCollection;
import org.owasp.dependencycheck.utils.FileFilterBuilder;
import org.owasp.dependencycheck.utils.Settings;
import org.owasp.dependencycheck.utils.UrlStringUtils;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.owasp.dependencycheck.exception.InitializationException;

/**
 * Used to analyze a Python package, and collect information that can be used to
 * determine the associated CPE.
 *
 * @author Dale Visser
 */
@Experimental
<span class="fc" id="L47">public class PythonPackageAnalyzer extends AbstractFileTypeAnalyzer {</span>

    /**
     * Used when compiling file scanning regex patterns.
     */
    private static final int REGEX_OPTIONS = Pattern.DOTALL
            | Pattern.CASE_INSENSITIVE;

    /**
     * Filename extensions for files to be analyzed.
     */
    private static final String EXTENSIONS = &quot;py&quot;;

    /**
     * Pattern for matching the module docstring in a source file.
     */
<span class="fc" id="L63">    private static final Pattern MODULE_DOCSTRING = Pattern.compile(</span>
            &quot;^(['\\\&quot;]{3})(.*?)\\1&quot;, REGEX_OPTIONS);

    /**
     * Matches assignments to version variables in Python source code.
     */
<span class="fc" id="L69">    private static final Pattern VERSION_PATTERN = Pattern.compile(</span>
            &quot;\\b(__)?version(__)? *= *(['\&quot;]+)(\\d+\\.\\d+.*?)\\3&quot;,
            REGEX_OPTIONS);

    /**
     * Matches assignments to title variables in Python source code.
     */
<span class="fc" id="L76">    private static final Pattern TITLE_PATTERN = compileAssignPattern(&quot;title&quot;);</span>

    /**
     * Matches assignments to summary variables in Python source code.
     */
<span class="fc" id="L81">    private static final Pattern SUMMARY_PATTERN = compileAssignPattern(&quot;summary&quot;);</span>

    /**
     * Matches assignments to URL/URL variables in Python source code.
     */
<span class="fc" id="L86">    private static final Pattern URI_PATTERN = compileAssignPattern(&quot;ur[il]&quot;);</span>

    /**
     * Matches assignments to home page variables in Python source code.
     */
<span class="fc" id="L91">    private static final Pattern HOMEPAGE_PATTERN = compileAssignPattern(&quot;home_?page&quot;);</span>

    /**
     * Matches assignments to author variables in Python source code.
     */
<span class="fc" id="L96">    private static final Pattern AUTHOR_PATTERN = compileAssignPattern(&quot;author&quot;);</span>

    /**
     * Filter that detects files named &quot;__init__.py&quot;.
     */
<span class="fc" id="L101">    private static final FileFilter INIT_PY_FILTER = new NameFileFilter(&quot;__init__.py&quot;);</span>

    /**
     * The file filter for python files.
     */
<span class="fc" id="L106">    private static final FileFilter PY_FILTER = new SuffixFileFilter(&quot;.py&quot;);</span>

    /**
     * The file filter used to determine which files this analyzer supports.
     */
<span class="fc" id="L111">    private static final FileFilter FILTER = FileFilterBuilder.newInstance().addExtensions(EXTENSIONS).build();</span>

    /**
     * Returns the name of the Python Package Analyzer.
     *
     * @return the name of the analyzer
     */
    @Override
    public String getName() {
<span class="fc" id="L120">        return &quot;Python Package Analyzer&quot;;</span>
    }

    /**
     * Tell that we are used for information collection.
     *
     * @return INFORMATION_COLLECTION
     */
    @Override
    public AnalysisPhase getAnalysisPhase() {
<span class="fc" id="L130">        return AnalysisPhase.INFORMATION_COLLECTION;</span>
    }

    /**
     * Returns the FileFilter
     *
     * @return the FileFilter
     */
    @Override
    protected FileFilter getFileFilter() {
<span class="fc" id="L140">        return FILTER;</span>
    }

    /**
     * No-op initializer implementation.
     *
     * @throws InitializationException never thrown
     */
    @Override
    protected void initializeFileTypeAnalyzer() throws InitializationException {
        // Nothing to do here.
<span class="fc" id="L151">    }</span>

    /**
     * Utility function to create a regex pattern matcher.
     *
     * @param name the value to use when constructing the assignment pattern
     * @return the compiled Pattern
     */
    private static Pattern compileAssignPattern(String name) {
<span class="fc" id="L160">        return Pattern.compile(</span>
                String.format(&quot;\\b(__)?%s(__)?\\b *= *(['\&quot;]+)(.*?)\\3&quot;, name),
                REGEX_OPTIONS);
    }

    /**
     * Analyzes python packages and adds evidence to the dependency.
     *
     * @param dependency the dependency being analyzed
     * @param engine the engine being used to perform the scan
     * @throws AnalysisException thrown if there is an unrecoverable error
     * analyzing the dependency
     */
    @Override
    protected void analyzeDependency(Dependency dependency, Engine engine)
            throws AnalysisException {
<span class="fc" id="L176">        final File file = dependency.getActualFile();</span>
<span class="fc" id="L177">        final File parent = file.getParentFile();</span>
<span class="fc" id="L178">        final String parentName = parent.getName();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (INIT_PY_FILTER.accept(file)) {</span>
            //by definition, the containing folder of __init__.py is considered the package, even the file is empty:
            //&quot;The __init__.py files are required to make Python treat the directories as containing packages&quot;
            //see section &quot;6.4 Packages&quot; from https://docs.python.org/2/tutorial/modules.html;
<span class="fc" id="L183">            dependency.setDisplayFileName(parentName + &quot;/__init__.py&quot;);</span>
<span class="fc" id="L184">            dependency.getProductEvidence().addEvidence(file.getName(),</span>
                    &quot;PackageName&quot;, parentName, Confidence.HIGHEST);

<span class="fc" id="L187">            final File[] fileList = parent.listFiles(PY_FILTER);</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            if (fileList != null) {</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">                for (final File sourceFile : fileList) {</span>
<span class="fc" id="L190">                    analyzeFileContents(dependency, sourceFile);</span>
                }
            }
<span class="fc" id="L193">        } else {</span>
<span class="fc" id="L194">            engine.getDependencies().remove(dependency);</span>
        }
<span class="fc" id="L196">    }</span>

    /**
     * This should gather information from leading docstrings, file comments,
     * and assignments to __version__, __title__, __summary__, __uri__, __url__,
     * __home*page__, __author__, and their all caps equivalents.
     *
     * @param dependency the dependency being analyzed
     * @param file the file name to analyze
     * @return whether evidence was found
     * @throws AnalysisException thrown if there is an unrecoverable error
     */
    private boolean analyzeFileContents(Dependency dependency, File file)
            throws AnalysisException {
        String contents;
        try {
<span class="fc" id="L212">            contents = FileUtils.readFileToString(file, Charset.defaultCharset()).trim();</span>
<span class="nc" id="L213">        } catch (IOException e) {</span>
<span class="nc" id="L214">            throw new AnalysisException(</span>
                    &quot;Problem occurred while reading dependency file.&quot;, e);
<span class="fc" id="L216">        }</span>
<span class="fc" id="L217">        boolean found = false;</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (!contents.isEmpty()) {</span>
<span class="fc" id="L219">            final String source = file.getName();</span>
<span class="fc" id="L220">            found = gatherEvidence(VERSION_PATTERN, contents, source,</span>
                    dependency.getVersionEvidence(), &quot;SourceVersion&quot;,
                    Confidence.MEDIUM);
<span class="fc" id="L223">            found |= addSummaryInfo(dependency, SUMMARY_PATTERN, 4, contents,</span>
                    source, &quot;summary&quot;);
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (INIT_PY_FILTER.accept(file)) {</span>
<span class="fc" id="L226">                found |= addSummaryInfo(dependency, MODULE_DOCSTRING, 2,</span>
                        contents, source, &quot;docstring&quot;);
            }
<span class="fc" id="L229">            found |= gatherEvidence(TITLE_PATTERN, contents, source,</span>
                    dependency.getProductEvidence(), &quot;SourceTitle&quot;,
                    Confidence.LOW);
<span class="fc" id="L232">            final EvidenceCollection vendorEvidence = dependency</span>
                    .getVendorEvidence();
<span class="fc" id="L234">            found |= gatherEvidence(AUTHOR_PATTERN, contents, source,</span>
                    vendorEvidence, &quot;SourceAuthor&quot;, Confidence.MEDIUM);
<span class="fc" id="L236">            found |= gatherHomePageEvidence(URI_PATTERN, vendorEvidence,</span>
                    source, &quot;URL&quot;, contents);
<span class="fc" id="L238">            found |= gatherHomePageEvidence(HOMEPAGE_PATTERN,</span>
                    vendorEvidence, source, &quot;HomePage&quot;, contents);
        }
<span class="fc" id="L241">        return found;</span>
    }

    /**
     * Adds summary information to the dependency
     *
     * @param dependency the dependency being analyzed
     * @param pattern the pattern used to perform analysis
     * @param group the group from the pattern that indicates the data to use
     * @param contents the data being analyzed
     * @param source the source name to use when recording the evidence
     * @param key the key name to use when recording the evidence
     * @return true if evidence was collected; otherwise false
     */
    private boolean addSummaryInfo(Dependency dependency, Pattern pattern,
            int group, String contents, String source, String key) {
<span class="fc" id="L257">        final Matcher matcher = pattern.matcher(contents);</span>
<span class="fc" id="L258">        final boolean found = matcher.find();</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (found) {</span>
<span class="fc" id="L260">            JarAnalyzer.addDescription(dependency, matcher.group(group),</span>
                    source, key);
        }
<span class="fc" id="L263">        return found;</span>
    }

    /**
     * Collects evidence from the home page URL.
     *
     * @param pattern the pattern to match
     * @param evidence the evidence collection to add the evidence to
     * @param source the source of the evidence
     * @param name the name of the evidence
     * @param contents the home page URL
     * @return true if evidence was collected; otherwise false
     */
    private boolean gatherHomePageEvidence(Pattern pattern,
            EvidenceCollection evidence, String source, String name,
            String contents) {
<span class="fc" id="L279">        final Matcher matcher = pattern.matcher(contents);</span>
<span class="fc" id="L280">        boolean found = false;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (matcher.find()) {</span>
<span class="fc" id="L282">            final String url = matcher.group(4);</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            if (UrlStringUtils.isUrl(url)) {</span>
<span class="fc" id="L284">                found = true;</span>
<span class="fc" id="L285">                evidence.addEvidence(source, name, url, Confidence.MEDIUM);</span>
            }
        }
<span class="fc" id="L288">        return found;</span>
    }

    /**
     * Gather evidence from a Python source file using the given string
     * assignment regex pattern.
     *
     * @param pattern to scan contents with
     * @param contents of Python source file
     * @param source for storing evidence
     * @param evidence to store evidence in
     * @param name of evidence
     * @param confidence in evidence
     * @return whether evidence was found
     */
    private boolean gatherEvidence(Pattern pattern, String contents,
            String source, EvidenceCollection evidence, String name,
            Confidence confidence) {
<span class="fc" id="L306">        final Matcher matcher = pattern.matcher(contents);</span>
<span class="fc" id="L307">        final boolean found = matcher.find();</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (found) {</span>
<span class="fc" id="L309">            evidence.addEvidence(source, name, matcher.group(4), confidence);</span>
        }
<span class="fc" id="L311">        return found;</span>
    }

    @Override
    protected String getAnalyzerEnabledSettingKey() {
<span class="fc" id="L316">        return Settings.KEYS.ANALYZER_PYTHON_PACKAGE_ENABLED;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>